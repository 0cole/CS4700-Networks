#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
import struct

class Router:

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        self.relations = {}
        self.sockets = {}
        self.ports = {}
        self.forwarding_table = {}
        self.updates = []
        self.update_counter = 0
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        print(f'----SENDING TO {network} ----> {message}')
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def sendNoRoute(self, ip):
        msg = {
            'src': self.our_addr(ip),
            'dst': ip,
            'type': 'no route',
            'msg': {}
        }
        self.send(ip, json.dumps(msg))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                print("Received message '%s' from %s" % (msg, srcif))

                try:

                    parsed_msg = json.loads(msg)
                    message_type = parsed_msg['type']
                    print(f'-----PARSED THE FOLLOWING MESSAGE: {message_type} -----> {parsed_msg}')
                    print(f'srcif ----> {srcif}')
                    self.handlePacket(parsed_msg, srcif)
                except json.JSONDecodeError as e:
                    print(f'Error parsing the json: {e}')
        return
        
    def storeUpdate(self, packet):
        self.updates.append((self.update_counter, packet))
        self.update_counter += 1

    def filterBySubnet(self, all_routes):
        possible_routes = []
        max_subnet = 0

        for route in all_routes:
            subnet = route['netmask']
            bin_subnet = bin(struct.unpack('!I', socket.inet_aton(subnet))[0])[2:]
            cidr = bin_subnet.count('1')
            
            if cidr == max_subnet:
                possible_routes.append(route)
            elif cidr > max_subnet:
                max_subnet = cidr
                possible_routes = [route]

        return possible_routes

    def filterByLocalpref(self, all_routes):
        possible_routes = []
        max_localpref = 0

        for route in all_routes:
            localpref = route['localpref']

            if localpref == max_localpref:
                possible_routes.append(route)
            elif localpref > max_localpref:
                max_localpref = localpref
                possible_routes = [route]
        return possible_routes

    def filterBySelfOrigin(self, all_routes):
        possible_routes = []

        for route in all_routes:
            if route['selfOrigin'] == True:
                possible_routes.append(route)

        # When there are no selfOrigin = True routes, just add all
        # and go to next step
        if len(possible_routes) == 0:
            possible_routes = all_routes
        return possible_routes

    def filterByASPath(self, all_routes):
        possible_routes = []
        min_aspath_len = float('inf')

        for route in all_routes:
            aspath_len = len(route['ASPath'])
            
            if aspath_len == min_aspath_len:
                possible_routes.append(route)
            elif aspath_len < min_aspath_len:
                min_aspath_len = aspath_len
                possible_routes = [route]
        return possible_routes

    def filterByOrigin(self, all_routes):
        possible_routes = []
        preference = ['IGP', 'EGP', 'UNK']
        min_idx = 2 # Start at UNK

        for route in all_routes:
            origin = route['origin']
            route_origin_idx = preference.index(origin)
            
            if route_origin_idx == min_idx:
                possible_routes.append(route)
            elif route_origin_idx < min_idx:
                min_idx = route_origin_idx
                possible_routes = [route]
        return possible_routes
    
    def filterByLowestSrc(self, all_routes):
        possible_ip = []
        lowest_ip = float('inf')

        for route in all_routes:
            src = route['peer']
            octets = map(int, src.split('.'))
            curr_ip = (next(octets) << 24) + (next(octets) << 16) + (next(octets) << 8) + next(octets)

            if curr_ip < lowest_ip:
                possible_ip = [route]
        return possible_ip

    def valididateRelationship(self, src, dst):
        """
        Update received from a customer: send updates to all other neighbors
        Update received from a peer or a provider: only send updates to your customers
        """

        src_rel = self.relations[src]
        dst_rel = self.relations[dst]

        print(f'src_rel ----> {src_rel}')
        print(f'dst_rel ----> {dst_rel}')

        if src_rel == 'cust':
            return dst
        elif dst_rel == 'cust':
            return dst
        return None


    def determineRoute(self, ip, srcif):
        """
        Generate all possible routes then filter in the follwing order
        until only 1 route remains.
        1. whichever route has the highest subnet mask
        2. highest localpref
        3. selfOrigin = True
        4. shortest ASPath
        5. origin (IGP > EGP > UNK)
        6. Lowest src ip
        """
        
        possible_routes, routes = [], []
        
        for network_arr, neighbors in self.forwarding_table.items():
            network = network_arr[0]
            netmask = network_arr[1]
            if self.applySubnetMask(ip, netmask) == \
                    self.applySubnetMask(network, netmask):
                possible_routes.append(neighbors)

        for route in possible_routes:
            routes += route

        if routes:
            if len(routes) > 1:
                routes = self.filterBySubnet(routes)
                print(f'after comparing subnets: {routes}')
            if len(routes) > 1:
                routes = self.filterByLocalpref(routes)
                print(f'after comparing localpref: {routes}')
            if len(routes) > 1:
                routes = self.filterBySelfOrigin(routes)
                print(f'after comparing selforigin: {routes}')
            if len(routes) > 1:
                routes = self.filterByASPath(routes)
                print(f'after comparing aspath: {routes}')
            if len(routes) > 1:
                routes = self.filterByOrigin(routes)
                print(f'after comparing origin: {routes}')
            if len(routes) > 1:
                routes = self.filterByLowestSrc(routes)
                print(f'after comparing lowest src: {routes}')

            if len(routes) == 1:
                opt_route = routes[0]['peer']
                confirmed_route = self.valididateRelationship(srcif, opt_route)

                print(f'----FOUND OPTIMAL ROUTE: {confirmed_route}')
                return confirmed_route
            else:
                self.sendNoRoute(ip)
        return None # If there are no valid routes
    
    def applySubnetMask(self, ip, subnet_mask):
        try:
            ip_octets = map(int, ip.split('.'))
            mask_octets = map(int, subnet_mask.split('.'))
            # mask with AND operation
            masked_ip = '.'.join(str(octet & mask) for octet, mask in zip(ip_octets, mask_octets))
            return masked_ip
        
        except ValueError:
            raise ValueError(f"Invalid IP or subnet mask: {ip}, {subnet_mask}")

    def update(self, packet, srcif):
        """
        1. Save this update for future reference
        2. Create an entry in the forward table
        3. For every neighbor, send the update announcement
        """
        # Store the update in a tuple with a counter that indicates when the packet was received
        self.storeUpdate(packet)

        peer = packet['src']
        network = packet['msg']['network']
        netmask = packet['msg']['netmask']
        localpref = packet['msg']['localpref']
        selfOrigin = packet['msg']['selfOrigin']
        ASPath = packet['msg']['ASPath']
        origin = packet['msg']['origin']

        # Save this in our forwarding table
        neighbor_dict = {
            'netmask': netmask,
            'network': network,
            'localpref': localpref,
            'selfOrigin': selfOrigin,
            'ASPath': ASPath,
            'origin': origin,
            'peer': peer
        }

        # Add new entry to forwarding table f it does not already exist
        if (network, netmask) not in self.forwarding_table:
            self.forwarding_table[(network, netmask)] = []
        self.forwarding_table[(network, netmask)].append(neighbor_dict)

        ASPath = [self.asn] + ASPath

        # Send to every neighbor in self.relations
        if peer in self.relations:
            for dst in self.relations.keys():
                confirmed_dst = self.valididateRelationship(srcif, dst)
                if confirmed_dst == None:
                    return False
                
                src = self.our_addr(dst)
                if peer != dst:
                    # Send ONLY the network, netmask, and aspath
                    update_packet = {
                        'src': src,
                        'dst': dst,
                        'type': 'update',
                        'msg': {
                            'network': network,
                            'netmask': netmask,
                            'ASPath': ASPath
                        }
                    }
                    try:
                        self.send(dst, json.dumps(update_packet))
                    except Exception as e:
                        print(f"ERROR WHEN UPDATING: {e}")
                        return
        return True
    
    def data(self, packet, srcif):
        """
        1. Create message to send
        2. Validate neighbor's route
        """
        peer = packet['dst']
        opt_peer = self.determineRoute(peer, srcif)

        # If there is an invalid relationship
        if opt_peer == None:
            return False

        print(f'----OPTIMAL PEER FOR {peer} ----> {opt_peer}')

        try:
            self.send(opt_peer, json.dumps(packet))
        except Exception as e:
            print(f"ERROR WHEN SENDING DATA: {e}")
            return
        return True
    
    def dump(self, packet):
        """
        1. Create dump dict
            a. put every entry in the forwarding table into dump['msg']
        2. Send dump dict to peer
        """
        peer = packet['src']
        src = self.our_addr(peer)
        dump = {
            'src': src,
            'dst': peer,
            'type': 'table',
            'msg': []
        }

        # Add each entry into the dump dict
        for network_arr, neighbors in self.forwarding_table.items():
            for neighbor in neighbors:
                neighbor_dict = {
                    'network': network_arr[0],
                    'netmask': network_arr[1],
                    'localpref': neighbor['localpref'],
                    'selfOrigin': neighbor['selfOrigin'],
                    'ASPath': neighbor['ASPath'],
                    'origin': neighbor['origin'],
                    'peer': neighbor['peer'],
                }
                dump['msg'].append(neighbor_dict)

        try:
            self.send(peer, json.dumps(dump))
        except Exception as e:
            print(f"ERROR WHEN DUMPING: {e}")
            return

        return True

    def withdraw(self, packet):
        peer = packet['src']
        self.storeUpdate(packet)

        networks_to_remove = packet['msg']

        for route in networks_to_remove:
            network = route['network']
            netmask = route['netmask']
            if (network, netmask) not in self.forwarding_table:
                return
            
            # Filter out entries that match peer
            forwarding_table_data = self.forwarding_table.get((network, netmask))
            updated_table_data = [entry for entry in forwarding_table_data if entry['peer'] != peer]
            self.forwarding_table[(network, netmask)] = updated_table_data

            if not updated_table_data:
                del self.forwarding_table[(network, netmask)]

        for dst in self.relations.keys():
            if peer != dst:
                packet['src'] = self.our_addr(dst)
                packet['dst'] = dst
                try:
                    self.send(dst, json.dumps(packet))
                except Exception as e:
                    print(f"ERROR WHEN UPDATING: {e}")
                    return
        return True

    def handlePacket(self, packet, srcif):
        noerror = False
        type = packet['type']
        
        if type == 'update':
            noerror = self.update(packet, srcif)
        elif type == 'data':
            noerror = self.data(packet, srcif)
        elif type == 'dump':
            noerror = self.dump(packet)
        elif type == 'withdraw':
            noerror = self.withdraw(packet)
        else:
            print(f'Unknown packet type')
            return
        
        #Check if an error occurred when handling the packet
        if not noerror:
            pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
