Throughout the project, I encountered several challenges. One major issue was that the router kept advertising aggregated routes even after some of their constituent routes were withdrawn, leading to incorrect routing tables. To solve this, I implemented a rebuild_forwarding_table method to reconstruct the forwarding table and re-aggregate routes based only on active updates, ensuring that we don't include any withdrawn routes. Another challenge was with the adjacency checks during route aggregation; mistakes in the bitwise operations caused non-adjacent routes to be incorrectly aggregated. I fixed this by correcting the bitwise logic in the aggregate_prefixes function and verifying with examples to ensure only truly adjacent routes were aggregated. Handling different relationships with neighbors, like customers, peers, and providers, presented difficulties when applying import and export policies. I addressed this by defining policies for each relationship type and implementing conditional logic in the message handling methods to enforce these policies, making sure routes were only advertised to appropriate neighbors. Keeping the forwarding table and related data structures consistent, especially after route withdrawals and during aggregations, was another challenge. I updated all relevant data structures whenever routes were added or removed, ensuring that any changes in one part of the router's state were reflected throughout the system. Lastly, applying BGP's tie-breaking rules to select the best route when multiple options were available was tricky. I implemented the tie-breaking criteria in the correct order—such as highest local preference, shortest AS path, and so on—and tested various scenarios where routes had similar attributes to confirm that the router consistently chose the optimal path.