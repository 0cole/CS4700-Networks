#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A, MX, CNAME, NS

DEBUG = True


class Server:
    def __init__(self, root_ip, domain, port):
        self.root_ip = root_ip
        self.domain = domain
        self.records = []

        if DEBUG: self.printToFile(f'==== OUR ROOT IP: {root_ip} =====')

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log("Bound to port %d" % self.port)
    

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()
    
    def printToFile(self, content):
        file = 'debug.txt'
        with open(file, 'a') as file:
            print(content, file=file)      

    def send(self, addr, message):
        self.log("Sending message:\n%s" % message)
        if DEBUG: self.printToFile(f'==== SENDING MESSAGE TO {addr} ====\n{message}\n\n')
        self.socket.sendto(message.pack(), addr)

    def recv(self, socket):
        data, addr = socket.recvfrom(65535)

        # Unpack the DNS request
        request = DNSRecord.parse(data)
        self.log("Received message:\n%s" % request)

        question = request.get_q()

        # parse the question and look for the records for all the matching addrs
        data = self.handleRequest(str(question))
        
        if data:
            response = request.reply()
            name = data[1]
            ttl = data[2] if data[2] else 5
            valid_addrs = data[3] 
            
            # add ns recordds to the AUTHORITY section
            if data[0] != 'NS':
                for record in self.records:
                    if record.rtype == QTYPE.NS and str(record.rname) == self.domain:
                        response.add_auth(RR(record.rname, QTYPE.NS, rdata=record.rdata, ttl=record.ttl))

            if data[0] == 'A': # ('A', name, ttl, addrs)
                for address in valid_addrs:
                    response.add_answer(RR(name, QTYPE.A, rdata=A(address), ttl=ttl))  
            elif data[0] == 'CNAME':
                for address in valid_addrs:
                    response.add_answer(RR(name, QTYPE.CNAME, rdata=CNAME(address), ttl=ttl))

                    if DEBUG:
                        self.printToFile(f'==== FOUND A CNAME FILE, RECURSIVELY SEARCHING FOR \'A\' RECORD ====')

                    # recursively search for A records
                    recursive_data = self.handleRequest(f' {address} A')
                    if recursive_data:
                        if recursive_data[0] == 'A':
                            cname_name = recursive_data[1]
                            cname_ttl = recursive_data[2] if recursive_data[2] else 5
                            cname_addrs = recursive_data[3]
                            for address in cname_addrs:
                                response.add_answer(RR(cname_name, QTYPE.A, rdata=A(address), ttl=cname_ttl))
                        else:
                            # handle other types later maybe
                            pass
                    else:
                        if DEBUG: self.printToFile(f'could not find any recursive records  for {address}')
            elif data[0] == 'MX':
                for address in valid_addrs:
                    priority, domain = address.split(' ', 1)
                    response.add_answer(RR(name, QTYPE.MX, rdata=MX(domain, int(priority)), ttl=ttl))
            elif data[0] == 'NS':
                for nameserver in valid_addrs:
                    response.add_answer(RR(name, QTYPE.NS, rdata=NS(nameserver), ttl=ttl))

                    if DEBUG:
                        self.printToFile(f'==== FOUND A NAMESERVER FILE, RECURSIVELY SEARCHING FOR \'A\' RECORD ====')
                    
                    recursive_data = self.handleRequest(f' {nameserver} A')
                    if recursive_data:
                        if recursive_data[0] == 'A':
                            ns_name = recursive_data[1]
                            ns_ttl = recursive_data[2] if recursive_data[2] else 5
                            ns_addrs = recursive_data[3]
                            for address in ns_addrs:
                                response.add_ar(RR(ns_name, QTYPE.A, rdata=A(address), ttl=ns_ttl))
                        else:
                            # handle other types later maybe
                            pass
                    else:
                        if DEBUG: self.printToFile(f'could not find any recursive records  for {address}')
        else:
            print('UNKNOWN REQUEST ENCOUNTERED. QUITTING...')
            if DEBUG: self.printToFile('UNKNOWN REQUEST ENCOUNTERED. QUITTING...')
            return

        self.send(addr, response)

    def parseZoneFile(self, file):
        with open(file, "r") as f:
            file_content = f.read()

        records = RR.fromZone(file_content)

        if DEBUG: self.printToFile('\n\n==== Printing received records from zone file ====\n')
        for record in records:
            if DEBUG: self.printToFile(record)
            if record.rtype == 6:
                self.domain = record.rname
                if DEBUG: self.printToFile(f'==== SERVING {record.rname} ====')

        return records

    def handleRequest(self, q, recursive=False):
        if DEBUG: self.printToFile(f'==== HANDLING REQUEST: {q} ====')
        q = q.strip()
        arr = q.split()

        self.printToFile(arr)

        if len(arr) == 4:
            name, ttl, r_type, qtype = arr
        elif len(arr) == 3:
            name, r_type, qtype = arr
            ttl = None # maybe we need to consider this later
        elif len(arr) == 2:
            name, qtype = arr
            ttl = None
        
        if name.startswith(';'): 
            name = name[1:]

        return_value = None
        addrs = []

        if qtype == 'A' or qtype == 'CNAME':
            for record in self.records:
                if name == record.get_rname():
                    if record.rtype == QTYPE.CNAME:
                        if DEBUG: self.printToFile(f'Found CNAME for {name}: {record.rdata}')
                        addrs.append(str(record.rdata))
                        return_value = 'CNAME'
                    elif record.rtype == QTYPE.A:
                        if DEBUG: self.printToFile(f'Found A record for {name}: {record.rdata}')
                        addrs.append(str(record.rdata))
                        return_value = 'A'
        elif qtype == 'MX':
            if DEBUG: self.printToFile(f'looking for corresponding email for {name} in our records')
            return_value = qtype
            for record in self.records:
                if name == record.get_rname():
                    if record.rtype == QTYPE.MX:
                        if DEBUG: self.printToFile(f'found email corresponding to {name}: {record.rdata}')
                        addrs.append(str(record.rdata))
        elif qtype == 'NS':
            if DEBUG: self.printToFile(f'looking for corresponding nameserver for {name} in our records')
            return_value = qtype
            for record in self.records:
                if name == record.get_rname():
                    if record.rtype == QTYPE.NS:
                        if DEBUG: self.printToFile(f'found nameserver corresponding to {name}: {record.rdata}')
                        addrs.append(str(record.rdata))
        
        if return_value:
            return (return_value, name, ttl, addrs)
        return None

    def run(self):
        self.records = self.parseZoneFile(args.zone)

        seq = 0
        while True:
            socks = select.select([self.socket], [], [], 0.1)[0]
            for conn in socks:
                self.recv(conn)

        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args()
    open('debug.txt', 'w') # debug file
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
